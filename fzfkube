#!/usr/bin/env bash
# /usr/share/bash-completion/completions/git
# https://github.com/junegunn/fzf/wiki/examples#git
set -x
#set -e

# declare BOLD=$(tput bold || tput md)
declare c_reset=$(tput sgr0)
declare c_green=$(tput setaf 2 || tput AF 2)
declare c_red=$(tput setaf 1 || tput AF 1)
declare NAMESPACE="kube-system"
declare PROMPT=""
declare CLUSTER="NONE"
declare LEVEL=0
declare -a CALL_LIST
declare -a PROMPT_CRUM
declare SELECTION_OPTIONS=""
declare POD=""

has() { # {{{
  command -v "$1" &> /dev/null
}
# }}}

ask() { # {{{
  read -r -n1 -p "$* " ans
  echo
  [[ ${ans^} == Y* ]]
}
# }}}

err() { # {{{
    printf "${c_red}%s${c_reset}" "$*" >&2
}
# }}}

die() { # {{{
  [[ -n "$1" ]] && err "$1"
  exit 1
}
# }}}

has fzf || die 'fzf not found'
# [[ -d "$PWD/.git" ]] || die 'not a git repo'

fzf() { # {{{
  local prompt
  if [[ $1 == --prompt=* ]]; then
    prompt="${1##*=}>"
    PROMPT="${1##*=}>"
    shift
  fi
  # Set default namespace
  #opts=( +s -e -i --reverse --cycle --prompt="kubectl>-c:${cluster}:-n:${namespace}>${prompt} " )
  opts=( +s -e -i --reverse --cycle --prompt="kubectl>clstr:${CLUSTER}:ns:${NAMESPACE}>${PROMPT} " )
  [[ -v FZMP_FZF_OPTIONS ]] && opts=( $FZMP_FZF_OPTIONS )
  command fzf "${opts[@]}" \
    --inline-info \
    --ansi \
    --no-clear \
    "$@"
}
# }}}

declare -A kubectl_cmds_descriptions=( # {{{
  ['namespaces']='Change or create new namespaces'
  ['clusters']='Change clusters'
  ['nodes']='Get list of nodes'
  ['pods']='Get list of pods'
  ['logs']='Get pod logs'
  ['clusters']='Select a different cluster'
	['describe']='Show details of a specific resource or group of resources'
  ['logs']='Print the logs for a container in a pod'
  ['podlogs']='Print the logs for a container in a pod'
  ['attach']='Attach to a running container'
  ['exec']='Execute a command in a container'
  ['port-forward']='Forward one or more local ports to a pod'
  ['proxy']='Run a proxy to the Kubernetes API server'
  ['cp']='Copy files and directories to and from containers.'
  ['auth']='Inspect authorization'
)
# }}}

declare -A implemented_kubectl_cmds=( # {{{
  ['namespaces']='kubectl_namespaces'
  ['clusters']='kubectl_clusters'
  ['nodes']='kubectl_get_nodes'
  ['pods']='kubectl_get_pods'
  ['logs']='kubectl_get_logs'
  ['podlogs']='kubectl_get_pod_logs'
  ['describe']='kubectl_describe_pod'
  ['exec']='kubectl_exec_pod'
  ['auth']='kubectl_auth_pod'
)
#}}}

declare -A pod_kubectl_cmds=( # {{{
  ['podlogs']='kubectl_get_pod_logs'
  ['describe']='kubectl_describe_pod'
  ['exec']='kubectl_exec_pod'
  ['auth']='kubectl_auth_pod'
)
#}}}


declare -A pod_node_kubectl_cmds=( # {{{
  ['podlogs']='kubectl_get_pod_logs'
  ['describe']='kubectl_describe_pod'
  ['exec']='kubectl_exec_pod'
  ['auth']='kubectl_auth_pod'
)
#}}}

kubectl_get_pods() { # {{{
  local list response key
  list=$(kubectl -n ${NAMESPACE} get pods)
  #show="kubectl -n ${NAMESPACE} logs $(cut -d\" \" -f1 | tr -s \" \" <<< {})"
  mapfile -t response < <( fzf --prompt='pods' --header="$header" \
  --expect=ctrl-x  --preview="kubectl -n ${NAMESPACE} logs {1}" <<< "$list")
  echo "get_pods data: ${data}" 2>&1 >> "/tmp/inline.log"
  key="${response[0]}"
  echo "get_pods:response ${response[1]}" 2>&1 >> "/tmp/inline.log"
  POD=$(echo ${response[1]} | tr -s " " | cut -d " " -f1)
  #PROMPT=$PROMPT"pods>$pod>"
  echo "get_pods exit: ${?} | level: $LEVEL " 2>&1 >> "/tmp/inline.log"
  if [[ -n $POD ]]; then
    PROMPT="pod>${POD}>"
    SELECTION_OPTIONS="pod_node_kubectl_cmds"
    #LEVEL=$(($LEVEL + 1))
   # echo "get_pods exit: ${?} | level: $LEVEL " 2>&1 >> "/tmp/inline.log"
   # PROMPT_CRUM[$LEVEL]="${PROMPT}"
   # CALL_LIST[$LEVEL]="${PICK}"
  fi
}
# }}}

kubectl_get_nodes() { # {{{
  local list response key
  list=$(kubectl -n ${NAMESPACE} get nodes)
  mapfile -t response < <(fzf --prompt='nodes' --header="$header" \
  --expect=ctrl-x  --preview="kubectl -n ${NAMESPACE} logs {1}" <<< "$list")
  key="${response[0]}"
  NODE=$(echo ${response[1]} | tr -s " " | cut -d " " -f1)
  #PROMPT=$PROMPT"pods>$pod>"
  PROMPT="nodes>$NODE>"
  SELECTION_OPTIONS="pod_node_kubectl_cmds"
  if [[ -n $NODE ]]; then
    PROMPT="pod>${POD}>"
    SELECTION_OPTIONS="pod_node_kubectl_cmds"
    LEVEL=$(($LEVEL + 1))
    PROMPT_CRUM[$LEVEL]="${PROMPT}"
    CALL_LIST[$LEVEL]="${PICK}"
  fi
}

kubectl_namespaces() { # {{{
  local list response header key
  list=$(kubectl get namespaces) || return 1
    mapfile -t response < <(fzf --prompt='namespaces' \
    --header="$header" --expect=ctrl-x <<< "$list")
  key="${response[0]}"
  NAMESPACE=$(echo ${response[1]} | tr -s " " | cut -d " " -f1)
}
# }}}

kubectl_clusters() { # {{{
  local list response header key namespace
  list=$(kubectl get namespaces) || return 1
    mapfile -t response < <(fzf --prompt='namespaces' \
    --header="$header" --expect=ctrl-x <<< "$list")
  key="${response[0]}"
  namespace=$(echo ${response[1]} | tr -s " " | cut -d " " -f1)
  fzf --prompt="cls:${cluster}>"
  kubectl config set-context $(kubectl config current-context) --namespace=${namespace} || return 1
}
# }}}

kubectl_get_pod_logs() {
  echo "inside kubectl_get_pod_logs" 2>&1 >> "/tmp/inline.log"
  trap `fzf --prompt="${PROMPT}log" -e --no-sort --tiebreak=index < <(kubectl -n $NAMESPACE log $POD)` EXIT

  # remove the previous entry saved
  LEVEL=$(($LEVEL - 1))
}

kubectl_get_node_logs() {
  echo "kubect get node logs" 2>&1 >> "/tmp/inside"
  fzf --prompt=">log" -e --no-sort --tiebreak=index < <(kubectl -n $NAMESPACE log $NODE)
}

kubectl_get_logs() {
  fzf --prompt="$PROMPT>log" -e --no-sort --tiebreak=index --preview="$show" < <(kubectl -n $NAMESPACE log $POD)
}

pick_cmd() {
  if [ $SELECTION_OPTIONS == "pod_node_kubectl_cmds" ];then
    echo "selection_options | level: ${LEVEL} | pick: ${PICK} | CALL_LIST ${CALL_LIST[*]} | CRUM: ${PROMPT_CRUM[*]}" 2>&1 >> "/tmp/inline.log"
    for c in "${!pod_node_kubectl_cmds[@]}"; do
      printf '%s%-15s%s -- %s\n' "${c_green}" "$c" "${c_reset}" "${kubectl_cmds_descriptions[$c]}"
    done | fzf | awk '{print $1}'
 # elif [[ -n $SELECTION_OPTIONS ]]; then
 #   echo ${SELECTION_OPTIONS} 2>&1 >> "/tmp/inline.log"
 #   echo ${SELECTION_OPTIONS}
 #   return
  else
    echo "no selection: $? | level: ${LEVEL} | pick: ${pick} | CALL_LIST ${CALL_LIST[*]} | CRUM: ${PROMPT_CRUM[*]}" 2>&1 >> "/tmp/inline.log"
    for c in "${!implemented_kubectl_cmds[@]}"; do
      printf '%s%-15s%s -- %s\n' "${c_green}" "$c" "${c_reset}" "${kubectl_cmds_descriptions[$c]}"
    done | fzf | awk '{print $1}'
  fi

  echo "inside pick_cmd" 2>&1 >> "/tmp/inline.log"

  trap 'exit 0' EXIT
}

main() {
  local pick
  i=0
  while pick=$(pick_cmd); do
    echo "begin while exit: ${$?} | level: ${LEVEL} | pick: ${pick} | CALL_LIST ${CALL_LIST[*]} | CRUM: ${PROMPT_CRUM[*]}" 2>&1 >> "/tmp/inline.log"
    if [[ -n $pick ]] && has "${implemented_kubectl_cmds[${pick%% *}]}"; then
      echo "pick selected: $pick" 2>&1 >> "/tmp/inline.log"
      PICK=$pick
      LEVEL=$(( $LEVEL + 1 ))
      CALL_LIST[$LEVEL]=$pick
      PROMPT_CRUM[$LEVEL]="${pick}>"
      #SELECTION_OPTIONS=""
      echo "CALL_LIST: ${CALL_LIST[*]}" 2>&1 >> "/tmp/inline.log"
      ${implemented_kubectl_cmds[$pick]}
    elif (( $? == 1 && $LEVEL > 0 )); then
      # Change the level so that we can exit the script .. eventually
      echo "Trap esc exit: $? | level: ${LEVEL} | pick: ${pick} | CALL_LIST ${CALL_LIST[*]} | CRUM: ${PROMPT_CRUM[*]}" 2>&1 >> "/tmp/inline.log"
      echo "Trap call_list:  ${CALL_LIST[${LEVEL}]}" 2>&1 >> "/tmp/inline.log"
      LEVEL=$(( $LEVEL - 1))
      call="${CALL_LIST[$LEVEL]}"
      #SELECTION_OPTIONS="${CALL_LIST[$LEVEL]}"
      SELECTION_OPTIONS=""
      PROMPT="${PROMPT_CRUM[$LEVEL]}"
      ${implemented_kubectl_cmds[$call]}
      #exit
    else
      echo "exiting" 2>&1 >> "/tmp/inline.log"
      break
    fi
    i=$(( $i + 1))
  done
  echo "last exit statement $? +${i} " 2>&1 >> "/tmp/inline.log"
  finish
}

reset_screen() {
  tput rmcup
}

finish() {
  reset_screen
}

trap finish EXIT SIGINT SIGTERM
main
