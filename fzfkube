#!/usr/bin/env bash
set -x
set -e
set -o pipefail

# /usr/share/bash-completion/completions/git
# https://github.com/junegunn/fzf/wiki/examples#git

# declare BOLD=$(tput bold || tput md)
declare c_reset=$(tput sgr0)
declare c_green=$(tput setaf 2 || tput AF 2)
declare c_red=$(tput setaf 1 || tput AF 1)
declare NAMESPACE="kube-system"
declare PROMPT=""
declare CLUSTER="NONE"
declare LEVEL=0
declare -a LASTFUNCTION[0]=""
declare -a PROMPT_CRUM[0]=""
declare SELECTION_OPTIONS=""
declare POD=""

has() { # {{{
  command -v "$1" &> /dev/null
}
# }}}

ask() { # {{{
  read -r -n1 -p "$* " ans
  echo
  [[ ${ans^} == Y* ]]
}
# }}}

err() { # {{{
    printf "${c_red}%s${c_reset}" "$*" >&2
}
# }}}

die() { # {{{
  [[ -n "$1" ]] && err "$1"
  exit 1
}
# }}}

has fzf || die 'fzf not found'
# [[ -d "$PWD/.git" ]] || die 'not a git repo'

fzf() { # {{{
  local prompt
  if [[ $1 == --prompt=* ]]; then
    prompt="${1##*=}>"
    PROMPT="${1##*=}>"
    shift
  fi
  # Set default namespace
  #opts=( +s -e -i --reverse --cycle --prompt="kubectl>-c:${cluster}:-n:${namespace}>${prompt} " )
  opts=( +s -e -i --reverse --cycle --prompt="kubectl>clstr:${CLUSTER}:ns:${NAMESPACE}>${PROMPT} " )
  [[ -v FZMP_FZF_OPTIONS ]] && opts=( $FZMP_FZF_OPTIONS )
  command fzf "${opts[@]}" \
    --inline-info \
    --ansi \
    --no-clear \
    "$@"
}
# }}}

declare -A kubectl_cmds_descriptions=( # {{{
  ['namespaces']='Change or create new namespaces'
  ['clusters']='Change clusters'
  ['nodes']='Get list of nodes'
  ['pods']='Get list of pods'
  ['logs']='Get pod logs'
  ['clusters']='Select a different cluster'
	['describe']='Show details of a specific resource or group of resources'
  ['logs']='Print the logs for a container in a pod'
  ['attach']='Attach to a running container'
  ['exec']='Execute a command in a container'
  ['port-forward']='Forward one or more local ports to a pod'
  ['proxy']='Run a proxy to the Kubernetes API server'
  ['cp']='Copy files and directories to and from containers.'
  ['auth']='Inspect authorization'
)
# }}}

declare -A implemented_kubectl_cmds=( # {{{
  ['namespaces']='kubectl_namespaces'
  ['clusters']='kubectl_clusters'
  ['nodes']='kubectl_get_nodes'
  ['pods']='kubectl_get_pods'
  ['logs']='kubectl_get_logs'
  ['logs']='kubectl_get_pod_logs'
  ['describe']='kubectl_describe_pod'
  ['exec']='kubectl_exec_pod'
  ['auth']='kubectl_auth_pod'
)
#}}}

declare -A pod_kubectl_cmds=( # {{{
  ['logs']='kubectl_get_pod_logs'
  ['describe']='kubectl_describe_pod'
  ['exec']='kubectl_exec_pod'
  ['auth']='kubectl_auth_pod'
)
#}}}

kubectl_get_pods() { # {{{
  local list response key
  list=$(kubectl -n ${NAMESPACE} get pods)
    mapfile -t response < <(fzf --prompt='pods' \
    --header="$header" --expect=ctrl-x <<< "$list")
  key="${response[0]}"
  POD=$(echo ${response[1]} | tr -s " " | cut -d " " -f1)
  #PROMPT=$PROMPT"pods>$pod>"
  PROMPT="pods>${POD}>"
  SELECTION_OPTIONS="pod_options"
  LEVEL=$(($LEVEL + 1))
  LASTFUNCTION[$LEVEL]=PICK
  PROMPT_CRUM[$LEVEL]=$PROMPT
}
# }}}

kubectl_get_nodes() { # {{{
  local list response key
  list=$(kubectl -n ${NAMESPACE} get nodes)
    mapfile -t response < <(fzf --prompt='nodes' \
    --header="$header" --expect=ctrl-x <<< "$list")
  key="${response[0]}"
  NODE=$(echo ${response[1]} | tr -s " " | cut -d " " -f1)
  #PROMPT=$PROMPT"pods>$pod>"
  PROMPT="nodes>$NODE>"
  SELECTION_OPTIONS="node_options"
  LEVEL=$(($LEVEL + 1))
  LASTFUNCTION[$LEVEL]=PICK
}

kubectl_namespaces() { # {{{
  local list response header key
  list=$(kubectl get namespaces) || return 1
    mapfile -t response < <(fzf --prompt='namespaces' \
    --header="$header" --expect=ctrl-x <<< "$list")
  key="${response[0]}"
  NAMESPACE=$(echo ${response[1]} | tr -s " " | cut -d " " -f1)
  #fzf --prompt="ns:${namespace}" <<< pick_cmd
  #kubectl config set-context $(kubectl config current-context) --namespace=${namespace} || return 1
  #kubectl config set-context $(kubectl config current-context) --namespace=${namespace} || return 1
}
# }}}

kubectl_clusters() { # {{{
  local list response header key namespace
  list=$(kubectl get namespaces) || return 1
    mapfile -t response < <(fzf --prompt='namespaces' \
    --header="$header" --expect=ctrl-x <<< "$list")
  key="${response[0]}"
  namespace=$(echo ${response[1]} | tr -s " " | cut -d " " -f1)
  fzf --prompt="cls:${cluster}>"
  kubectl config set-context $(kubectl config current-context) --namespace=${namespace} || return 1

}
# }}}

kubectl_get_pod_logs() {
  local show="kubectl -n $NAMESPACE logs $POD <<< {}"
  #fzf --prompt="$PROMPT>log" -e --no-sort --tiebreak=index --bind="enter:execute:cat $show | less -R" --preview="$show" < <(kubectl -n $NAMESPACE log $POD)
  #fzf --prompt="$PROMPT>log" -e --no-sort --tiebreak=index --bind="enter:execute:$show" --preview="cat $show" < <(kubectl -n $NAMESPACE log $POD)
  #LEVEL=$(($LEVEL + 1))
  #PROMPT_CRUM[$LEVEL]="log"
  #PROMPT="${PROMPT}>log"
  trap `fzf --prompt="${PROMPT}log" -e --no-sort --tiebreak=index < <(kubectl -n $NAMESPACE log $POD)` EXIT
}

kubectl_get_node_logs() {
  local show="kubectl -n $NAMESPACE logs $POD <<< {}"
  fzf --prompt=">log" -e --no-sort --tiebreak=index < <(kubectl -n $NAMESPACE log $NODE)
}



kubectl_get_logs() {
  list=$(kubectl -n NAMESPACE logs ) || return 1
    mapfile -t response < <(fzf --prompt='namespaces' \
    --header="$header" --expect=ctrl-x <<< "$list")
  key="${response[0]}"
  namespace=$(echo ${response[1]} | tr -s " " | cut -d " " -f1)
  fzf --prompt="cls:${cluster}>"
  fzf --prompt="$PROMPT>log" -e --no-sort --tiebreak=index --preview="$show" < <(kubectl -n $NAMESPACE log $POD)
}

pick_cmd() {
  if [ -n $SELECTION_OPTIONS ];then
    if [[ $SELECTION_OPTIONS == "pod_options" ]]; then
      echo "selection_options = level: ${LEVEL} | exit : ${?} | pick: ${PICK} | last_function: ${LASTFUNCTION[*]} CRUM: ${PROMPT_CRUM[*]}" >> "/tmp/inside.log"
      for c in "${!pod_kubectl_cmds[@]}"; do
        printf '%s%-15s%s -- %s\n' "${c_green}" "$c" "${c_reset}" "${kubectl_cmds_descriptions[$c]}"
      done | fzf | awk '{print $1}'
    else
      echo "selection_options else = level: ${LEVEL} | exit : ${?} pick: ${PICK} | last_function: ${LASTFUNCTION[*]} CRUM: ${PROMPT_CRUM[*]}" >> "/tmp/inside.log"
      for c in "${!implemented_kubectl_cmds[@]}"; do
        printf '%s%-15s%s -- %s\n' "${c_green}" "$c" "${c_reset}" "${kubectl_cmds_descriptions[$c]}"
      done | fzf | awk '{print $1}'
    fi
  else
    echo "implemented_kubectl_cmds = level: ${LEVEL} | exit : ${?} | pick: ${PICK} | last_function: ${LASTFUNCTION[*]} | CRUM: ${PROMPT_CRUM[*]}" >> "/tmp/inside.log"
    for c in "${!implemented_kubectl_cmds[@]}"; do
      printf '%s%-15s%s -- %s\n' "${c_green}" "$c" "${c_reset}" "${kubectl_cmds_descriptions[$c]}"
    done | fzf | awk '{print $1}'
  fi

  trap 'exit 0' EXIT
}

main() {
  local pick
  while pick=$(pick_cmd); do
    if [[ -n $pick ]] && has "${implemented_kubectl_cmds[${pick%% *}]}"; then
      ${implemented_kubectl_cmds[$pick]}
    elif (( $? == 1 && $LEVEL >= 0 )); then
      # Change the level so that we can exit the script .. eventually
      echo "Trapping ESC key = level: ${LEVEL} | exit : ${?} | pick: ${PICK} | last_function: ${LASTFUNCTION[*]} | CRUM: ${PROMPT_CRUM[*]}" >> "/tmp/inside.log"
      LEVEL=$(($LEVEL - 1))
      if (( $LEVEL == 0 )); then
        SELECTION_OPTIONS=""
        PROMP=""
      else
        SELECTION_OPTIONS=$LASTFUNCTION[$LEVEL]
        PROMP=$PROMPT_CRUM[$LEVEL]
      fi
    else
      echo "exiting" 2>&1 >> "/tmp/inline.log"
      break
    fi
  done
  echo "last exit statement $?" 2>&1 >> "/tmp/inline.log"
  #finish
}

reset_screen() {
  tput rmcup
}

finish() {
  reset_screen
}

trap finish EXIT SIGINT SIGTERM
main
